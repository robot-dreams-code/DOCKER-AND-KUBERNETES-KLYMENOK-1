Домашнє завдання: Pod, Deployment та стратегії оновлення (module-03/lesson-07)
Виконав: Владислав Войтенко
У цьому завданні ми глибоко досліджуємо життєвий цикл застосунків у Kubernetes. Мета — на практиці вивчити, як керувати розгортаннями (Deployment),
оновлювати їх конфігурацію за допомогою ConfigMap та аналізувати різні стратегії оновлення (RollingUpdate та Recreate).

#Крок 1: Початкове розгортання з 10 репліками
Спочатку було створено два маніфести: configmap.yaml для конфігурації та deployment.yaml для розгортання застосунку course-app.
Деплоймент був налаштований на запуск 10 реплік, а початкове повідомлення APP_MESSAGE було завантажено з ConfigMap.
Результат команди kubectl apply -f . та kubectl get pods:
![Початковий деплоймент 10 реплік](imgs/Screenshot from 2025-12-02 11-40-48.png)

#Крок 2: Оновлення конфігурації через ConfigMap
На цьому етапі було змінено значення APP_MESSAGE у файлі configmap.yaml і застосовано зміни командою kubectl apply -f configmap.yaml.
Ключове спостереження: Поди, які вже працювали, не оновилися автоматично. Вони продовжували використовувати старе значення, кешоване під час їхнього старту.
Перевірка старого значення в одному з подів після оновлення ConfigMap:
![Старе значення в поді після оновлення ConfigMap](imgs/krok-2.xcf)

Щоб змусити поди "підхопити" нову конфігурацію, було виконано примусовий перезапуск деплойменту командою kubectl rollout restart deployment/course-app-deployment.
Це ініціювало поступове оновлення (RollingUpdate), під час якого старі поди були замінені на нові, вже з оновленою змінною середовища.
Процес перезапуску подів:
![Перезапуск деплойменту для застосування ConfigMap](imgs/Screenshot from 2025-12-02 12-54-34.png)

#Крок 3: Оновлення образу контейнера
Далі було оновлено версію застосунку шляхом зміни тегу образу в deployment.yaml з :v1.0 на :v1.1. Після застосування змін було простежено за процесом поступового оновлення.
Процес оновлення (rollout) деплойменту:
![Статус оновлення образу](imgs/Screenshot from 2025-12-02 11-45-58.png)

#Крок 4: Дослідження стратегій оновлення
Це основна дослідницька частина завдання, де порівнювались дві стратегії оновлення.
##4.1. Стратегія RollingUpdate
Це стратегія за замовчуванням. Вона забезпечує нульовий час простою, поступово замінюючи старі поди на нові.
Я дослідив її поведінку з різними параметрами maxSurge (скільки додаткових подів можна створити понад бажану кількість) та maxUnavailable (скільки подів може бути недоступно).
Спостереження: При maxSurge: 5 та maxUnavailable: 0 Kubernetes спочатку створював до 5 нових подів (доводячи загальну кількість до 15), і лише потім починав видаляти старі.
Це гарантує, що сервіс не втрачає потужності під час оновлення, але вимагає додаткових ресурсів.
Процес RollingUpdate з налаштованими параметрами:
![Процес RollingUpdate](imgs/Screenshot from 2025-12-02 11-53-45.png)

##4.2. Стратегія Recreate
Ця стратегія працює радикально інакше: спочатку зупиняє всі старі поди, і тільки після їх повного видалення починає створювати нові.
Спостереження: Під час оновлення застосунок був повністю недоступний протягом короткого періоду часу.
Всі старі поди перейшли в стан Terminating, і лише після цього почали створюватися нові.
Процес оновлення за стратегією Recreate:
![Процес Recreate](imgs/Screenshot from 2025-12-02 12-58-28.png)
![Процес Recreate](imgs/Screenshot from 2025-12-02 12-58-41.png)
Висновки та порівняльний аналіз
Вибір стратегії оновлення — це завжди компроміс між доступністю, вимогами до ресурсів та простотою.

Критерій	        RollingUpdate (Поступове оновлення)	                                    Recreate (Перестворення)
Час простою (Downtime)	Нульовий. Завжди є активні поди, що обслуговують трафік.	            Присутній. Існує проміжок часу, коли застосунок недоступний.
Вимоги до ресурсів	Вищі. Тимчасово потрібно більше ресурсів для maxSurge подів.	            Нижчі. Ніколи не перевищує задану кількість реплік.
Процес оновлення	Плавний та контрольований.	                                            Радикальний: "вимкнути все, увімкнути все".
Найкращий сценарій	Для більшості production-середовищ, де критична висока доступність.	    Для середовищ розробки або для застосунків, які не підтримують одночасну роботу двох версій (наприклад, через несумісні зміни в базі даних).
